Directory structure:
‚îî‚îÄ‚îÄ weather_ai_app/
    ‚îú‚îÄ‚îÄ README.md
    ‚îú‚îÄ‚îÄ db.sqlite3
    ‚îú‚îÄ‚îÄ ds.py
    ‚îú‚îÄ‚îÄ manage.py
    ‚îú‚îÄ‚îÄ requirements.txt
    ‚îú‚îÄ‚îÄ weather/
    ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
    ‚îÇ   ‚îú‚îÄ‚îÄ admin.py
    ‚îÇ   ‚îú‚îÄ‚îÄ apps.py
    ‚îÇ   ‚îú‚îÄ‚îÄ models.py
    ‚îÇ   ‚îú‚îÄ‚îÄ tests.py
    ‚îÇ   ‚îú‚îÄ‚îÄ urls.py
    ‚îÇ   ‚îú‚îÄ‚îÄ views.py
    ‚îÇ   ‚îú‚îÄ‚îÄ migrations/
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ __init__.py
    ‚îÇ   ‚îî‚îÄ‚îÄ templates/
    ‚îÇ       ‚îî‚îÄ‚îÄ weather.html
    ‚îî‚îÄ‚îÄ weather_ai_app/
        ‚îú‚îÄ‚îÄ __init__.py
        ‚îú‚îÄ‚îÄ asgi.py
        ‚îú‚îÄ‚îÄ settings.py
        ‚îú‚îÄ‚îÄ urls.py
        ‚îî‚îÄ‚îÄ wsgi.py

================================================
FILE: README.md
================================================
# weather_ai_app

This project implements a weather application leveraging AI for enhanced prediction and personalized weather information.  The application focuses on providing accurate and timely weather updates, incorporating machine learning models to improve forecasting accuracy beyond standard meteorological data. This allows for more precise weather predictions, particularly in areas with limited historical data or complex weather patterns. The long-term goal is to expand the application's capabilities to include hyperlocal forecasting and personalized alerts based on user preferences and activities.

The current implementation provides a basic framework for data acquisition, processing, and presentation.  Future development will include integration with advanced AI models for improved prediction accuracy and the incorporation of user-specific data to personalize the weather experience. The application is designed with scalability in mind, allowing for future expansion to incorporate additional weather data sources and sophisticated forecasting algorithms.

This project is designed as a modular and extensible platform. The architecture allows for easy integration of new features and data sources.  The use of Python and Django provides a robust and well-supported foundation for future development.


## Features

*   **Real-time weather updates:** Retrieves current weather data from a reliable API.
*   **AI-enhanced prediction:**  (Future implementation) Utilizes machine learning to improve forecast accuracy.
*   **User-friendly interface:** (Future implementation)  Provides a clean and intuitive interface for accessing weather information.
*   **Personalized alerts:** (Future implementation)  Sends customized alerts based on user preferences.


## Installation

1.  Clone the repository: `git clone <repository_url>`
2.  Create a virtual environment: `python3 -m venv venv`
3.  Activate the virtual environment:  `source venv/bin/activate` (Linux/macOS) or `venv\Scripts\activate` (Windows)
4.  Install dependencies: `pip install -r requirements.txt`
5.  Migrate the database: `python manage.py migrate`
6.  Run the development server: `python manage.py runserver`


## Usage

The application is primarily accessed through the Django framework.  To view a simple example of accessing data (assuming a future implementation with a view providing weather data):

```python
from weather.models import WeatherData # Assuming a 'WeatherData' model exists

# Fetch the latest weather data (replace with your specific query)
latest_weather = WeatherData.objects.latest('timestamp')

print(f"Temperature: {latest_weather.temperature}")
print(f"Condition: {latest_weather.condition}")
```


## Technologies

| Technology        | Version (Example) |
|-----------------|--------------------|
| Python           | 3.9                |
| Django           | 4.2                |
| Database         | PostgreSQL (Example) |
| API              | OpenWeatherMap (Example)  |


## License

This project is licensed under the [MIT License](LICENSE).





================================================
FILE: db.sqlite3
================================================
[Non-text file]


================================================
FILE: ds.py
================================================
import os
import ast
import importlib.metadata
import subprocess

def find_python_files(root_dir):
    """
    Finds all Python files in the given directory.

    Args:
        root_dir (str): The root directory to search.

    Returns:
        list: A list of paths to Python files.
    """
    python_files = []
    for dirpath, dirnames, filenames in os.walk(root_dir):
        for filename in filenames:
            if filename.endswith('.py'):
                python_files.append(os.path.join(dirpath, filename))
    return python_files

def extract_imports(file_path):
    """
    Extracts imported module names from a Python file.

    Args:
        file_path (str): The path to the Python file.

    Returns:
        set: A set of imported module names.
    """
    imports = set()
    with open(file_path, 'r', encoding='utf-8') as file:
        tree = ast.parse(file.read())
        for node in ast.walk(tree):
            if isinstance(node, ast.Import):
                for alias in node.names:
                    imports.add(alias.name)
            elif isinstance(node, ast.ImportFrom):
                imports.add(node.module)
    return imports

def is_package_installable(package_name):
    """
    Checks if a package is installable using pip.

    Args:
        package_name (str): The name of the package.

    Returns:
        bool: True if installable, False otherwise.
    """
    try:
        result = subprocess.run(['pip', 'show', package_name], capture_output=True, text=True)
        return result.returncode == 0
    except FileNotFoundError:
        print("Pip is not installed. Please install pip.")
        return False
    except Exception:
        return False


def get_package_version(package_name):
    """
    Gets the installed version of a package using importlib.metadata.

    Args:
        package_name (str): The name of the package.

    Returns:
        str: The version of the package, or None if not found.
    """
    try:
        return importlib.metadata.version(package_name)
    except importlib.metadata.PackageNotFoundError:
        try:
            # Try pip to get the version
            result = subprocess.run(['pip', 'show', package_name], capture_output=True, text=True)
            if result.returncode == 0:
                for line in result.stdout.splitlines():
                    if line.startswith('Version:'):
                        return line.split(': ')[1]
            return None
        except FileNotFoundError:
            print("Pip is not installed. Please install pip.")
            return None
        except Exception as e:
            print(f"Error getting version for {package_name}: {e}")
            return None


def generate_requirements(root_dir, output_file='requirements.txt'):
    """
    Generates a requirements.txt file based on imports found in Python files.

    Args:
        root_dir (str): The root directory to search for Python files.
        output_file (str): The path to the output requirements.txt file.
    """
    python_files = find_python_files(root_dir)
    all_imports = set()

    for file_path in python_files:
        all_imports.update(extract_imports(file_path))

    # Filter out None values before processing versions
    all_imports = {imp for imp in all_imports if imp is not None}

    # Avoid default packages (expanded list)
    default_packages = {
        'os', 'sys', 'math', 'datetime', 'time', 'json', 'random', 'urllib',
        'unittest', 'logging', 're', 'collections', 'io', 'argparse', 'socket',
        'threading', 'multiprocessing', 'asyncio', 'enum', 'typing', 'copy',
        'functools', 'itertools', 'contextlib', 'abc', 'pathlib', 'subprocess',
        'django.apps', 'django.contrib', 'django.core.asgi', 'django.core.management',
        'django.core.wsgi', 'django.db', 'django.shortcuts', 'django.test', 'django.urls',
        'django' #Catch all for django
    }

    filtered_imports = all_imports - default_packages

    with open(output_file, 'w') as f:
        for package_name in sorted(filtered_imports):
            if is_package_installable(package_name):  # Added check here
                version = get_package_version(package_name)
                if version:
                    f.write(f"{package_name}=={version}\n")
                else:
                    f.write(f"{package_name}\n")  # Write without version if not found
                    print(f"Warning: Could not determine version for {package_name}")
            else:
                print(f"Skipping {package_name} as it doesn't seem to be a valid installable package.")

    print(f"Generated requirements.txt in {output_file}")


if __name__ == "__main__":
    # Replace 'your_project_directory' with the actual path to your project
    project_directory = '.'  # Current directory
    generate_requirements(project_directory)


================================================
FILE: manage.py
================================================
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'weather_ai_app.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()



================================================
FILE: requirements.txt
================================================
google.generativeai==0.8.4
importlib.metadata==8.6.1
requests==2.32.3



================================================
FILE: weather/__init__.py
================================================



================================================
FILE: weather/admin.py
================================================
from django.contrib import admin

# Register your models here.



================================================
FILE: weather/apps.py
================================================
from django.apps import AppConfig


class WeatherConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'weather'



================================================
FILE: weather/models.py
================================================
from django.db import models

# Create your models here.



================================================
FILE: weather/tests.py
================================================
from django.test import TestCase

# Create your tests here.



================================================
FILE: weather/urls.py
================================================
from django.urls import path
from . import views

urlpatterns = [
    path('', views.chatbot_view, name='chatbot'),
    path('clear/', views.clear_chat, name='clear_chat'),
]



================================================
FILE: weather/views.py
================================================
from django.shortcuts import render

# Create your views here.
import google.generativeai as genai
import requests
from django.shortcuts import render
import os

GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY")
WEATHER_API_KEY = "3c487a963733c205c52caed7dba21c87"

genai.configure(api_key=GEMINI_API_KEY)
model = genai.GenerativeModel("gemini-2.0-flash")

def chatbot_view(request):
    if 'chat_history' not in request.session:
        request.session['chat_history'] = []

    if request.method == 'POST':
        user_input = request.POST.get('query')
        chat_history = request.session['chat_history']
        chat_history.append({'sender': 'user', 'text': user_input})

        # Step 1: Let Gemini decide what to do
        weather_check_prompt = f"""
        User said: "{user_input}"

        If this message requires weather info, reply with: WEATHER:<city>
        If not, reply: CHAT
        If city is unknown, reply: UNKNOWN
        """
        check_response = model.generate_content(weather_check_prompt).text.strip()

        if check_response.startswith("WEATHER:"):
            city = check_response.split("WEATHER:")[1].strip()
            url = f"http://api.openweathermap.org/data/2.5/weather?q={city}&appid={WEATHER_API_KEY}&units=metric"
            data = requests.get(url).json()

            if data.get("cod") == 200:
                temp = data["main"]["temp"]
                desc = data["weather"][0]["description"]

                # Step 2: Now ask Gemini to respond naturally
                prompt = f"""
                The user asked: "{user_input}"
                Current weather in {city}: {temp}√Ç¬∞C, {desc}

                Reply in a friendly, human tone with this info.
                """
                smart_response = model.generate_content(prompt).text.strip()
            else:
                smart_response = f"Sorry, I couldn't find weather for {city}."
        elif check_response == "UNKNOWN":
            smart_response = "I need the city name to get weather details. Can you mention the city?"
        else:
            # Generic chat
            chat_prompt = f"""You're a helpful weather chatbot.
User said: {user_input}
Reply casually but helpfully."""
            smart_response = model.generate_content(chat_prompt).text.strip()

        chat_history.append({'sender': 'bot', 'text': smart_response})
        request.session['chat_history'] = chat_history
        request.session.modified = True

    return render(request, 'weather.html', {
        'chat_history': request.session.get('chat_history', [])
    })
    
from django.shortcuts import redirect

def clear_chat(request):
    if 'chat_history' in request.session:
        del request.session['chat_history']
    return redirect('chatbot')



================================================
FILE: weather/migrations/__init__.py
================================================



================================================
FILE: weather/templates/weather.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>AI Weather Chatbot</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gradient-to-br from-blue-100 to-white min-h-screen flex items-center justify-center p-4">
    <div class="w-full max-w-xl bg-white shadow-lg rounded-lg p-6">
        <h2 class="text-2xl font-bold text-center mb-4 text-blue-700">üå§Ô∏è AI Weather Chatbot</h2>

        <!-- Chat Box -->
        <div class="h-96 overflow-y-auto border border-gray-300 rounded-lg p-4 mb-4 bg-gray-50" id="chat-box">
            {% for msg in chat_history %}
                {% if msg.sender == "user" %}
                    <div class="flex justify-end mb-2">
                        <div class="bg-blue-500 text-white p-3 rounded-lg max-w-xs">
                            {{ msg.text }}
                        </div>
                    </div>
                {% else %}
                    <div class="flex justify-start mb-2">
                        <div class="bg-gray-200 text-gray-800 p-3 rounded-lg max-w-xs">
                            {{ msg.text }}
                        </div>
                    </div>
                {% endif %}
            {% endfor %}
        </div>

        <div class="flex justify-start mb-2">
            <a href="{% url 'clear_chat' %}" class="bg-red-500 hover:bg-red-600 text-white px-3 py-1 rounded-lg text-sm">
                üóëÔ∏è Clear Chat
            </a>
        </div>


        <!-- Chat Form -->
        <form method="POST" class="flex gap-2">
            {% csrf_token %}
            <input type="text" name="query" placeholder="Ask about the weather..." required
                class="flex-1 border border-gray-300 rounded-lg px-4 py-2 focus:outline-none focus:ring-2 focus:ring-blue-400">
            <button type="submit"
                class="bg-blue-600 hover:bg-blue-700 text-white font-semibold px-4 py-2 rounded-lg">Send</button>
        </form>
    </div>

    <script>
        // Auto-scroll to bottom on load
        const chatBox = document.getElementById('chat-box');
        chatBox.scrollTop = chatBox.scrollHeight;
    </script>
</body>
</html>



================================================
FILE: weather_ai_app/__init__.py
================================================



================================================
FILE: weather_ai_app/asgi.py
================================================
"""
ASGI config for weather_ai_app project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/4.2/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'weather_ai_app.settings')

application = get_asgi_application()



================================================
FILE: weather_ai_app/settings.py
================================================
"""
Django settings for weather_ai_app project.

Generated by 'django-admin startproject' using Django 4.2.11.

For more information on this file, see
https://docs.djangoproject.com/en/4.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/4.2/ref/settings/
"""

from pathlib import Path

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/4.2/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-$s&ko9lfqu47q6h#kc+@2fkcxsw)-vp81@vp*x*5$!ore=xev9'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'weather',  # Your weather app
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'weather_ai_app.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'weather_ai_app.wsgi.application'


# Database
# https://docs.djangoproject.com/en/4.2/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}


# Password validation
# https://docs.djangoproject.com/en/4.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/4.2/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/4.2/howto/static-files/

STATIC_URL = 'static/'

# Default primary key field type
# https://docs.djangoproject.com/en/4.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'



================================================
FILE: weather_ai_app/urls.py
================================================
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('weather.urls')),
]



================================================
FILE: weather_ai_app/wsgi.py
================================================
"""
WSGI config for weather_ai_app project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/4.2/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'weather_ai_app.settings')

application = get_wsgi_application()


